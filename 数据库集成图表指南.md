# 数据库集成图表指南

本文档详细说明如何将您的数据库数据集成到业财融合管理系统的饼状图和折线图中。

## 1. 当前数据来源分析

### 1.1 数据来源现状

目前，您的系统可能使用以下几种方式获取图表数据：

1. **硬编码的模拟数据**：直接在代码中定义的静态数据
2. **API调用**：从后端API获取数据，但API可能返回的是模拟数据
3. **部分数据库数据**：系统可能已经从数据库获取了部分数据，如表格中显示的业务事件

### 1.2 数据流程分析

典型的数据流程应该是：

```
数据库 -> 后端API -> 前端请求 -> 数据处理 -> 图表显示
```

## 2. 数据库集成方案

### 2.1 后端API开发

首先，需要在后端创建或修改API端点，从数据库获取图表所需的数据：

#### 2.1.1 饼状图数据API（业务类型分布）

```python
# 在app.py或相关后端文件中添加
@app.get("/api/business/type-distribution")
async def get_business_type_distribution(current_user = Depends(get_current_user)):
    """获取业务类型分布数据"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # 查询业务类型分布
        cursor.execute("""
            SELECT 
                event_type as type, 
                COUNT(*) as count
            FROM 
                business_events
            GROUP BY 
                event_type
            ORDER BY 
                count DESC
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            return {"labels": [], "values": []}
        
        # 处理查询结果
        labels = []
        values = []
        
        for row in results:
            labels.append(row["type"])
            values.append(row["count"])
        
        return {
            "labels": labels,
            "values": values
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"获取业务类型分布数据失败: {str(e)}")
```

#### 2.1.2 折线图数据API（财务趋势）

```python
@app.get("/api/financial/trends")
async def get_financial_trends(
    period: str = "month",  # 'week', 'month', 'quarter', 'year'
    current_user = Depends(get_current_user)
):
    """获取财务趋势数据"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # 根据周期确定日期范围和分组
        if period == "week":
            days = 7
            date_format = "%Y-%m-%d"  # 按天分组
            group_by = "DATE(transaction_date)"
        elif period == "month":
            days = 30
            date_format = "%Y-%m-%d"  # 按天分组
            group_by = "DATE(transaction_date)"
        elif period == "quarter":
            days = 90
            date_format = "%Y-%m-%d"  # 按周分组
            group_by = "strftime('%Y-%W', transaction_date)"
        else:  # year
            days = 365
            date_format = "%Y-%m"  # 按月分组
            group_by = "strftime('%Y-%m', transaction_date)"
        
        # 计算日期范围
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        # 查询收入数据
        cursor.execute(f"""
            SELECT 
                strftime('{date_format}', transaction_date) as date,
                SUM(amount) as total
            FROM 
                financial_transactions
            WHERE 
                transaction_date BETWEEN ? AND ?
                AND direction = '收入'
            GROUP BY 
                {group_by}
            ORDER BY 
                date
        """, (start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d")))
        
        income_results = cursor.fetchall()
        
        # 查询支出数据
        cursor.execute(f"""
            SELECT 
                strftime('{date_format}', transaction_date) as date,
                SUM(amount) as total
            FROM 
                financial_transactions
            WHERE 
                transaction_date BETWEEN ? AND ?
                AND direction = '支出'
            GROUP BY 
                {group_by}
            ORDER BY 
                date
        """, (start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d")))
        
        expense_results = cursor.fetchall()
        conn.close()
        
        # 处理查询结果
        dates = []
        income = []
        expense = []
        
        # 创建日期到金额的映射
        income_map = {row["date"]: row["total"] for row in income_results}
        expense_map = {row["date"]: row["total"] for row in expense_results}
        
        # 合并所有日期
        all_dates = sorted(set(list(income_map.keys()) + list(expense_map.keys())))
        
        for date in all_dates:
            dates.append(date)
            income.append(income_map.get(date, 0))
            expense.append(expense_map.get(date, 0))
        
        return {
            "dates": dates,
            "income": income,
            "expense": expense
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"获取财务趋势数据失败: {str(e)}")
```

### 2.2 前端集成

修改前端代码，从API获取数据并显示在图表中：

#### 2.2.1 饼状图数据获取和显示

```python
def load_pie_chart_data(self):
    """从API加载饼图数据"""
    try:
        # 从主窗口获取token
        token = self.parent().token if self.parent() and hasattr(self.parent(), 'token') else None
        headers = {"Authorization": f"Bearer {token}"} if token else {}
        
        # 发送API请求
        response = requests.get(
            "http://localhost:8000/api/business/type-distribution",
            headers=headers
        )
        
        if response.status_code == 200:
            data = response.json()
            self.create_pie_chart(data)
        else:
            print(f"获取业务类型分布数据失败: {response.status_code}")
            # 使用模拟数据作为备份
            self.create_pie_chart(self.generate_mock_pie_data())
    except Exception as e:
        print(f"加载饼图数据异常: {str(e)}")
        # 使用模拟数据作为备份
        self.create_pie_chart(self.generate_mock_pie_data())

def create_pie_chart(self, data):
    """创建饼图"""
    # 清除之前的图表
    self.pie_figure.clear()
    
    # 创建子图
    ax = self.pie_figure.add_subplot(111)
    
    # 获取数据
    labels = data.get("labels", [])
    values = data.get("values", [])
    
    # 如果没有数据，显示提示信息
    if not labels or not values or sum(values) == 0:
        ax.text(0.5, 0.5, '暂无数据', 
                horizontalalignment='center',
                verticalalignment='center',
                transform=ax.transAxes,
                color='white',
                fontsize=14)
        ax.axis('off')
        self.pie_canvas.draw()
        return
    
    # 设置颜色
    colors = ['#4285F4', '#34A853', '#FBBC05', '#EA4335', '#8AB4F8']
    
    # 确保颜色足够
    while len(colors) < len(labels):
        colors.extend(colors)
    
    # 绘制饼图
    wedges, texts, autotexts = ax.pie(
        values, 
        labels=None,  # 不直接在饼图上显示标签
        autopct='%1.1f%%', 
        startangle=90, 
        colors=colors[:len(labels)],
        wedgeprops={'edgecolor': '#121212', 'linewidth': 1, 'alpha': 0.9},
        textprops={'color': '#FFFFFF', 'fontsize': 10}
    )
    
    # 设置自动文本的样式
    for autotext in autotexts:
        autotext.set_color('#FFFFFF')
        autotext.set_fontsize(9)
    
    # 添加图例
    ax.legend(
        wedges, 
        labels, 
        loc="center right", 
        bbox_to_anchor=(1.1, 0.5),
        fontsize=9,
        frameon=False,  # 移除图例边框
        labelcolor='white'  # 图例文字颜色
    )
    
    # 设置标题
    ax.set_title('业务类型分布', color='#FFFFFF', fontsize=12, pad=20)
    
    # 等比例显示
    ax.axis('equal')
    
    # 设置背景透明
    ax.set_facecolor('none')
    
    # 自动调整布局
    self.pie_figure.tight_layout(pad=2.0)
    self.pie_figure.patch.set_alpha(0.0)  # 设置图形背景透明
    
    # 刷新画布
    self.pie_canvas.draw()

def generate_mock_pie_data(self):
    """生成模拟饼图数据（作为备份）"""
    return {
        "labels": ["销售", "采购", "报销", "合同", "其他"],
        "values": [35, 25, 20, 15, 5]
    }
```

#### 2.2.2 折线图数据获取和显示

```python
def load_trend_chart_data(self):
    """从API加载趋势图数据"""
    try:
        # 从主窗口获取token
        token = self.parent().token if self.parent() and hasattr(self.parent(), 'token') else None
        headers = {"Authorization": f"Bearer {token}"} if token else {}
        
        # 发送API请求
        response = requests.get(
            "http://localhost:8000/api/financial/trends?period=month",
            headers=headers
        )
        
        if response.status_code == 200:
            data = response.json()
            self.create_trend_chart(data)
        else:
            print(f"获取财务趋势数据失败: {response.status_code}")
            # 使用模拟数据作为备份
            self.create_trend_chart(self.generate_mock_trend_data())
    except Exception as e:
        print(f"加载趋势图数据异常: {str(e)}")
        # 使用模拟数据作为备份
        self.create_trend_chart(self.generate_mock_trend_data())

def create_trend_chart(self, data):
    """创建趋势折线图"""
    # 清除之前的图表
    self.trend_figure.clear()
    
    # 创建子图
    ax = self.trend_figure.add_subplot(111)
    
    # 获取数据
    dates = data.get("dates", [])
    income = data.get("income", [])
    expense = data.get("expense", [])
    
    # 如果没有数据，显示提示信息
    if not dates or (not income and not expense):
        ax.text(0.5, 0.5, '暂无数据', 
                horizontalalignment='center',
                verticalalignment='center',
                transform=ax.transAxes,
                color='white',
                fontsize=14)
        ax.axis('off')
        self.trend_canvas.draw()
        return
    
    # 绘制折线图
    if income:
        ax.plot(dates, income, marker='o', linestyle='-', color='#34A853', linewidth=2, label='收入')
    if expense:
        ax.plot(dates, expense, marker='o', linestyle='-', color='#EA4335', linewidth=2, label='支出')
    
    # 设置网格线
    ax.grid(True, linestyle='--', alpha=0.3, color='#666666')
    
    # 设置坐标轴标签
    ax.set_xlabel('日期', color='#FFFFFF', fontsize=10)
    ax.set_ylabel('金额 (元)', color='#FFFFFF', fontsize=10)
    
    # 设置标题
    ax.set_title('财务趋势', color='#FFFFFF', fontsize=12, pad=20)
    
    # 设置坐标轴刻度标签颜色
    ax.tick_params(axis='x', colors='#FFFFFF', rotation=45)
    ax.tick_params(axis='y', colors='#FFFFFF')
    
    # 设置图例
    if income or expense:
        ax.legend(frameon=False, labelcolor='white', loc='upper right')
    
    # 设置背景透明
    ax.set_facecolor('none')
    
    # 自动调整布局
    self.trend_figure.tight_layout(pad=2.0)
    self.trend_figure.patch.set_alpha(0.0)  # 设置图形背景透明
    
    # 刷新画布
    self.trend_canvas.draw()

def generate_mock_trend_data(self):
    """生成模拟趋势图数据（作为备份）"""
    # 生成最近30天的日期
    end_date = datetime.now()
    dates = [(end_date - timedelta(days=i)).strftime("%Y-%m-%d") for i in range(30, 0, -1)]
    
    # 生成收入和支出数据
    income = []
    expense = []
    
    base_income = 50000
    base_expense = 40000
    
    for i in range(30):
        # 添加一些随机波动
        income_factor = random.uniform(0.9, 1.1)
        expense_factor = random.uniform(0.85, 1.15)
        
        # 添加轻微的上升趋势
        trend_factor = 1 + (i * 0.01)
        
        income.append(round(base_income * income_factor * trend_factor))
        expense.append(round(base_expense * expense_factor * trend_factor))
    
    return {
        "dates": dates,
        "income": income,
        "expense": expense
    }
```

### 2.3 数据刷新机制

添加数据刷新机制，确保图表显示最新数据：

```python
def refresh_data(self):
    """刷新所有数据"""
    # 显示加载中状态
    self.status_label.setText("正在刷新数据...")
    
    # 加载各种数据
    self.load_stats_data()  # 加载统计数据
    self.load_pie_chart_data()  # 加载饼图数据
    self.load_trend_chart_data()  # 加载趋势图数据
    self.load_recent_transactions()  # 加载最近交易记录
    
    # 更新刷新时间
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    self.last_refresh_label.setText(f"上次刷新: {current_time}")
    
    # 恢复状态
    self.status_label.setText("数据刷新完成")
    
    # 2秒后清除状态消息
    QTimer.singleShot(2000, lambda: self.status_label.setText(""))
```

## 3. 数据库表结构分析与优化

为了支持图表数据查询，可能需要确保数据库表结构合理，并包含必要的字段：

### 3.1 业务事件表 (business_events)

```sql
CREATE TABLE IF NOT EXISTS business_events (
    id INTEGER PRIMARY KEY,
    event_type TEXT NOT NULL,  -- 事件类型：销售、采购、报销等
    project_name TEXT NOT NULL,
    project_code TEXT,
    amount REAL NOT NULL,
    event_date TEXT NOT NULL,  -- 事件日期
    description TEXT,
    department_id INTEGER,
    created_by INTEGER,
    status TEXT NOT NULL,      -- 状态：待审批、审批中、已审批、已完成等
    customer_id INTEGER,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- 添加索引以提高查询性能
CREATE INDEX IF NOT EXISTS idx_business_events_type ON business_events(event_type);
CREATE INDEX IF NOT EXISTS idx_business_events_date ON business_events(event_date);
CREATE INDEX IF NOT EXISTS idx_business_events_status ON business_events(status);
```

### 3.2 财务交易表 (financial_transactions)

```sql
CREATE TABLE IF NOT EXISTS financial_transactions (
    id INTEGER PRIMARY KEY,
    business_event_id INTEGER,
    account_code TEXT,
    account_name TEXT,
    amount REAL NOT NULL,
    direction TEXT NOT NULL,   -- 方向：收入、支出
    transaction_date TEXT NOT NULL,
    fiscal_year INTEGER,
    fiscal_period INTEGER,
    description TEXT,
    created_by INTEGER,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (business_event_id) REFERENCES business_events(id)
);

-- 添加索引以提高查询性能
CREATE INDEX IF NOT EXISTS idx_financial_transactions_date ON financial_transactions(transaction_date);
CREATE INDEX IF NOT EXISTS idx_financial_transactions_direction ON financial_transactions(direction);
CREATE INDEX IF NOT EXISTS idx_financial_transactions_business_event ON financial_transactions(business_event_id);
```

## 4. 实施步骤

### 4.1 后端API实施

1. 确认数据库表结构是否满足需求，必要时进行调整
2. 在后端添加新的API端点，实现从数据库获取图表数据的功能
3. 测试API端点，确保返回正确的数据格式和内容

### 4.2 前端集成实施

1. 修改前端代码，添加从API获取数据的方法
2. 更新图表创建方法，使用从API获取的数据
3. 添加数据刷新机制，确保图表显示最新数据
4. 添加错误处理和备用数据机制，确保在API请求失败时仍能显示图表

### 4.3 测试与调优

1. 测试整个数据流程，确保数据从数据库正确传递到图表
2. 检查图表显示效果，确保数据可视化清晰、准确
3. 测试不同数据量和数据分布情况下的图表显示效果
4. 优化查询性能，确保在数据量较大时仍能快速加载图表

## 5. 常见问题与解决方案

### 5.1 数据格式不一致

**问题**：API返回的数据格式与图表期望的格式不一致
**解决方案**：在前端添加数据转换逻辑，将API返回的数据转换为图表所需的格式

```python
def transform_pie_data(self, api_data):
    """转换API返回的饼图数据格式"""
    labels = []
    values = []
    
    for item in api_data:
        labels.append(item["name"])
        values.append(item["value"])
    
    return {
        "labels": labels,
        "values": values
    }
```

### 5.2 数据量过大导致图表加载缓慢

**问题**：数据量过大导致图表加载缓慢或显示不清晰
**解决方案**：
- 在后端进行数据聚合，减少传输的数据量
- 实现数据分页或时间范围筛选
- 添加数据缓存机制

```python
# 后端数据聚合示例
@app.get("/api/financial/trends/aggregated")
async def get_aggregated_financial_trends(
    period: str = "month",
    max_points: int = 30,  # 最大数据点数量
    current_user = Depends(get_current_user)
):
    # 根据period和max_points聚合数据
    # ...
```

### 5.3 空数据处理

**问题**：数据库中没有相关数据时，图表显示异常
**解决方案**：添加空数据检查和处理逻辑

```python
def create_pie_chart(self, data):
    # ...
    
    # 检查是否有数据
    if not labels or not values or sum(values) == 0:
        # 显示"暂无数据"提示
        ax.text(0.5, 0.5, '暂无数据', 
                horizontalalignment='center',
                verticalalignment='center',
                transform=ax.transAxes,
                color='white',
                fontsize=14)
        ax.axis('off')
        self.pie_canvas.draw()
        return
    
    # ...
```

## 6. 高级功能扩展

### 6.1 交互式图表

添加交互式功能，如点击图表元素显示详细信息：

```python
def setup_chart_interaction(self):
    """设置图表交互功能"""
    self.pie_canvas.mpl_connect('pick_event', self.on_pie_slice_clicked)
    
def on_pie_slice_clicked(self, event):
    """处理饼图切片点击事件"""
    if event.artist.get_label():
        category = event.artist.get_label()
        # 显示该类别的详细信息
        self.show_category_details(category)
```

### 6.2 图表筛选和时间范围选择

添加筛选控件，允许用户选择不同的数据视图：

```python
def setup_chart_filters(self):
    """设置图表筛选控件"""
    filter_container = QWidget()
    filter_layout = QHBoxLayout(filter_container)
    
    # 添加时间范围选择
    period_label = QLabel("时间范围:")
    period_combo = QComboBox()
    period_combo.addItems(["本周", "本月", "本季度", "本年"])
    period_combo.setCurrentIndex(1)  # 默认选择"本月"
    period_combo.currentIndexChanged.connect(self.on_period_changed)
    
    filter_layout.addWidget(period_label)
    filter_layout.addWidget(period_combo)
    filter_layout.addStretch()
    
    return filter_container

def on_period_changed(self, index):
    """处理时间范围变化"""
    periods = ["week", "month", "quarter", "year"]
    selected_period = periods[index]
    
    # 重新加载趋势图数据
    self.load_trend_chart_data(period=selected_period)
```

### 6.3 数据导出功能

添加数据导出功能，允许用户导出图表数据：

```python
def setup_export_buttons(self):
    """设置数据导出按钮"""
    export_container = QWidget()
    export_layout = QHBoxLayout(export_container)
    
    export_button = QPushButton("导出数据")
    export_button.clicked.connect(self.export_chart_data)
    
    export_layout.addStretch()
    export_layout.addWidget(export_button)
    
    return export_container

def export_chart_data(self):
    """导出图表数据"""
    options = QFileDialog.Options()
    file_name, _ = QFileDialog.getSaveFileName(
        self,
        "导出数据",
        "",
        "CSV文件 (*.csv);;Excel文件 (*.xlsx)",
        options=options
    )
    
    if file_name:
        try:
            if file_name.endswith('.csv'):
                self.export_to_csv(file_name)
            elif file_name.endswith('.xlsx'):
                self.export_to_excel(file_name)
            
            QMessageBox.information(self, "导出成功", f"数据已成功导出到 {file_name}")
        except Exception as e:
            QMessageBox.warning(self, "导出失败", f"导出数据时发生错误: {str(e)}")
```

## 7. 总结

通过实施本文档中的方案，您可以将数据库中的实际数据集成到饼状图和折线图中，实现真实数据的可视化展示。主要步骤包括：

1. 开发后端API，从数据库获取图表所需的数据
2. 修改前端代码，从API获取数据并显示在图表中
3. 添加数据刷新机制，确保图表显示最新数据
4. 实现错误处理和备用数据机制，提高系统稳定性
5. 优化数据库表结构和查询性能，支持高效的数据获取

通过这些改进，您的系统将能够展示真实的业务数据，提供更有价值的业务洞察。
