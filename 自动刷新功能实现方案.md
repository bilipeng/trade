# 自动刷新功能实现方案

## 需求概述

在业财融合管理系统中，需要实现以下自动刷新功能：

1. 每次完成操作后自动刷新数据（如提交审核、通过审核等）
2. 确保用户始终看到最新的数据状态
3. 避免用户手动刷新的麻烦
4. 提高系统的实时性和用户体验

## 实现方案

### 方案一：操作后自动调用刷新方法（推荐）

这是最直接的方案，在每个操作完成后直接调用相应视图的刷新方法。

#### 1. 在主窗口中添加全局刷新方法

在`main_window.py`中添加全局刷新方法：

```python
def refresh_current_view(self):
    """刷新当前视图的数据"""
    current_widget = self.content_tabs.currentWidget()
    
    if hasattr(current_widget, "load_data"):
        try:
            # 显示刷新中的状态
            self.statusBar.showMessage("正在刷新数据...", 2000)
            
            # 调用当前视图的load_data方法
            current_widget.load_data()
            
            # 更新状态栏
            self.statusBar.showMessage("数据刷新成功", 2000)
        except Exception as e:
            self.statusBar.showMessage(f"刷新失败: {str(e)}", 3000)
            QMessageBox.warning(self, "刷新失败", f"刷新数据时发生错误: {str(e)}")
    else:
        self.statusBar.showMessage("当前视图不支持刷新", 2000)
```

#### 2. 修改业务视图中的操作方法

在`views/business_view.py`中修改提交审批方法：

```python
def submit_to_approval(self, business_id):
    """提交业务事件至审批流程"""
    try:
        # 调用新API将业务事件提交到审批流程
        response = requests.post(
            f"http://localhost:8000/business_events/{business_id}/submit-to-approval",
            headers={"Authorization": f"Bearer {self.token}"}
        )
        
        if response.status_code == 200:
            QMessageBox.information(self, "提交成功", "业务事件已成功提交到审批流程")
            
            # 自动刷新数据
            self.load_data()
            
            # 如果用户确认，切换到审批管理界面
            reply = QMessageBox.question(
                self, "提交成功", 
                "业务事件已成功提交到审批流程，是否立即跳转到审批管理界面？",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.Yes
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                # 找到主窗口
                main_window = self.window()
                if main_window and hasattr(main_window, "content_tabs") and hasattr(main_window, "approval_view"):
                    # 切换到审批管理选项卡
                    main_window.content_tabs.setCurrentWidget(main_window.approval_view)
                    
                    # 刷新审批视图数据
                    main_window.approval_view.load_data()
                else:
                    QMessageBox.information(self, "提示", "请手动切换到审批管理界面查看详情")
        else:
            QMessageBox.warning(self, "提交失败", f"提交到审批流程失败: {response.text}")
    except Exception as e:
        QMessageBox.warning(self, "错误", f"提交过程中发生错误: {str(e)}")
```

#### 3. 修改审批视图中的操作方法

在`views/approval_view.py`中修改审批通过方法：

```python
def approve(self, approval_id):
    """审批通过"""
    reply = QMessageBox.question(
        self, '确认操作', 
        "确定要通过此审批吗？", 
        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
        QMessageBox.StandardButton.No
    )
    
    if reply == QMessageBox.StandardButton.Yes:
        try:
            response = requests.post(
                f"http://localhost:8000/approvals/{approval_id}/approve",
                headers={"Authorization": f"Bearer {self.token}"}
            )
            
            if response.status_code == 200:
                result = response.json()
                QMessageBox.information(self, "操作成功", "审批已通过")
                
                # 自动刷新数据
                self.load_data()
                
                # 如果所有审批都已完成，显示创建财务记录的询问
                if not result.get("next_approval", True):
                    self.prompt_create_finance_record(approval_id)
            else:
                QMessageBox.warning(self, "操作失败", f"审批通过失败: {response.text}")
        except Exception as e:
            QMessageBox.warning(self, "错误", f"操作时发生错误: {str(e)}")
```

同样修改审批拒绝方法。

#### 4. 修改财务视图中的操作方法

在`views/finance_view.py`中修改创建财务记录方法：

```python
def save_data(self):
    """保存数据"""
    # 验证输入
    # ...
    
    try:
        # 发送请求
        response = requests.post(
            "http://localhost:8000/financial_records",
            json=data,
            headers={"Authorization": f"Bearer {self.token}"}
        )
        
        if response.status_code == 200:
            result = response.json()
            QMessageBox.information(self, "添加成功", f"财务记录已添加，ID: {result['id']}")
            
            # 自动刷新数据
            self.load_data()
            
            # 更新业务事件状态为已入账
            try:
                status_response = requests.post(
                    f"http://localhost:8000/business_events/{business_event_id}/status",
                    json={"status": "已入账"},
                    headers={"Authorization": f"Bearer {self.token}"}
                )
            except:
                # 忽略状态更新错误
                pass
            
            self.accept()
        else:
            QMessageBox.warning(self, "添加失败", f"无法添加财务记录: {response.text}")
    except Exception as e:
        QMessageBox.warning(self, "错误", f"保存数据时发生错误: {str(e)}")
```

### 方案二：添加自动刷新定时器

这种方案会定期自动刷新数据，不依赖于用户操作。

#### 1. 在主窗口中添加定时器

在`main_window.py`的`__init__`方法中添加定时器：

```python
from PyQt6.QtCore import QTimer

def __init__(self):
    super().__init__()
    self.settings = QSettings("FinanceApp", "BizFinanceSystem")
    self.user_data = None
    self.token = None
    
    # 添加自动刷新定时器
    self.refresh_timer = QTimer(self)
    self.refresh_timer.timeout.connect(self.auto_refresh)
    
    # 检查是否已有token，如果有尝试自动登录
    token = self.settings.value("access_token", "")
    if token:
        self.try_auto_login(token)
    else:
        self.show_login()
```

#### 2. 添加自动刷新方法

```python
def auto_refresh(self):
    """自动刷新当前视图"""
    # 获取当前视图
    current_widget = self.content_tabs.currentWidget()
    
    # 如果当前视图有load_data方法，调用它
    if hasattr(current_widget, "load_data"):
        try:
            current_widget.load_data()
            self.statusBar.showMessage("数据已自动刷新", 1000)
        except Exception as e:
            # 自动刷新出错时不显示错误对话框，只在状态栏显示错误信息
            self.statusBar.showMessage(f"自动刷新失败: {str(e)}", 2000)
```

#### 3. 在登录成功后启动定时器

在`login_successful`方法中启动定时器：

```python
def login_successful(self, data):
    """登录成功后的处理"""
    self.user_data = data["user"]
    self.token = data["token"]
    
    # 如果登录窗口存在，关闭它
    if hasattr(self, 'login_window') and self.login_window is not None:
        self.login_window.close()
        self.login_window = None
        
    # 初始化主界面
    self.init_ui()
    
    # 启动自动刷新定时器（每60秒刷新一次）
    refresh_interval = self.settings.value("refresh_interval", 60000, type=int)
    self.refresh_timer.start(refresh_interval)
    
    self.show()
```

#### 4. 在退出登录时停止定时器

在`logout`方法中停止定时器：

```python
def logout(self):
    """退出登录"""
    reply = QMessageBox.question(
        self, 
        '确认退出', 
        '确定要退出登录吗？',
        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
        QMessageBox.StandardButton.No
    )
    
    if reply == QMessageBox.StandardButton.Yes:
        # 停止自动刷新定时器
        self.refresh_timer.stop()
        
        # 清除token
        self.settings.remove("access_token")
        
        # 关闭当前窗口并显示登录窗口
        self.close()
        self.show_login()
```

#### 5. 添加刷新间隔设置

在系统设置对话框中添加刷新间隔设置：

```python
def show_settings_dialog(self):
    """显示系统设置对话框"""
    # 创建一个简单的设置对话框
    dialog = QDialog(self)
    dialog.setWindowTitle("系统设置")
    dialog.setMinimumWidth(400)
    
    layout = QVBoxLayout(dialog)
    
    # 添加设置选项
    form_layout = QFormLayout()
    
    # 自动刷新设置
    auto_refresh_check = QCheckBox("启用")
    auto_refresh_check.setChecked(self.refresh_timer.isActive())
    form_layout.addRow("自动刷新:", auto_refresh_check)
    
    # 刷新间隔设置
    refresh_interval_spin = QSpinBox()
    refresh_interval_spin.setRange(10, 600)  # 10秒到10分钟
    refresh_interval_spin.setSuffix(" 秒")
    refresh_interval_spin.setValue(self.refresh_timer.interval() // 1000)
    form_layout.addRow("刷新间隔:", refresh_interval_spin)
    
    layout.addLayout(form_layout)
    
    # 添加按钮
    button_layout = QHBoxLayout()
    cancel_button = QPushButton("取消")
    cancel_button.clicked.connect(dialog.reject)
    
    save_button = QPushButton("保存")
    save_button.clicked.connect(dialog.accept)
    
    button_layout.addStretch()
    button_layout.addWidget(cancel_button)
    button_layout.addWidget(save_button)
    
    layout.addLayout(button_layout)
    
    # 显示对话框
    if dialog.exec() == QDialog.DialogCode.Accepted:
        # 保存设置
        if auto_refresh_check.isChecked():
            # 启动定时器
            interval = refresh_interval_spin.value() * 1000  # 转换为毫秒
            self.refresh_timer.setInterval(interval)
            self.refresh_timer.start()
        else:
            # 停止定时器
            self.refresh_timer.stop()
        
        # 保存设置到QSettings
        self.settings.setValue("auto_refresh", auto_refresh_check.isChecked())
        self.settings.setValue("refresh_interval", refresh_interval_spin.value() * 1000)
        
        QMessageBox.information(self, "设置已保存", "系统设置已保存")
```

### 方案三：使用WebSocket实现实时更新（高级方案）

这种方案需要在后端实现WebSocket服务，当数据发生变化时，服务器主动推送更新通知给客户端。这是最高效的实时更新方案，但实现复杂度较高。

由于当前系统架构可能不支持WebSocket，这里不详细展开此方案。如果未来需要更高效的实时更新，可以考虑升级系统架构，引入WebSocket支持。

## 推荐实施方案

考虑到系统当前架构和实施难度，我推荐采用**方案一：操作后自动调用刷新方法**，并结合**方案二：添加自动刷新定时器**的部分功能。

### 具体实施步骤

1. 在主窗口中添加全局刷新方法
2. 修改各个视图中的操作方法，在操作完成后自动调用刷新方法
3. 添加自动刷新定时器（可选功能，作为补充）
4. 在系统设置中添加自动刷新相关选项（可选功能）

### 实施优先级

1. **高优先级**：在各个操作方法中添加自动刷新调用
2. **中优先级**：添加全局刷新方法
3. **低优先级**：添加自动刷新定时器和相关设置

## 注意事项

1. **性能考虑**：频繁刷新可能会影响系统性能，特别是在数据量大的情况下
2. **用户体验**：刷新过程中可能会导致界面短暂卡顿，应添加适当的视觉反馈
3. **错误处理**：自动刷新过程中的错误应该静默处理，避免频繁弹出错误对话框
4. **网络考虑**：在网络不稳定的环境中，频繁刷新可能会导致更多的网络错误

## 代码示例：全局刷新按钮实现

除了自动刷新，还可以在主窗口中添加一个全局刷新按钮，让用户可以手动触发刷新：

```python
# 在MainWindow的init_ui方法中
# 添加刷新按钮
refresh_action = QAction("🔄 刷新", self)
refresh_action.setToolTip("刷新当前视图数据")
refresh_action.triggered.connect(self.refresh_current_view)  # 连接到刷新方法
quick_actions.addAction(refresh_action)
```

这样，用户可以通过点击刷新按钮手动刷新数据，同时系统也会在关键操作后自动刷新数据，确保数据始终保持最新状态。
