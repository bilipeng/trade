# 仪表盘数据库集成指南

本文档提供了将业财融合管理系统仪表盘、扇形图和折线图与您自己的数据库集成的详细步骤。

## 目录

1. [概述](#概述)
2. [准备工作](#准备工作)
3. [仪表盘数据集成](#仪表盘数据集成)
4. [扇形图数据集成](#扇形图数据集成)
5. [折线图数据集成](#折线图数据集成)
6. [完整代码示例](#完整代码示例)
7. [测试与调试](#测试与调试)
8. [常见问题解决](#常见问题解决)

## 概述

目前，您的系统仪表盘、扇形图和折线图可能使用的是模拟数据或硬编码数据，而非从您的数据库中获取的实际数据。本指南将帮助您修改代码，使这些可视化组件显示您数据库中的真实数据。

## 准备工作

### 1. 确认数据库结构

在开始修改代码前，您需要了解您的数据库结构。以下是可能需要的表和字段：

- **业务事件表**（business_events）：包含事件类型、金额、日期等字段
- **财务记录表**（financial_transactions）：包含交易金额、方向（收入/支出）、日期等字段
- **审批表**（approvals）：包含审批状态、关联业务事件等字段
- **预算表**（budgets）：包含预算金额、已用金额、年份、月份等字段

### 2. 找到当前数据加载代码

在您的项目中找到负责加载仪表盘数据的代码文件，通常是`dashboard.py`或类似名称的文件。查找类似以下的函数：

```python
def loadData(self):
    # 可能包含API调用或模拟数据生成
    pass

def updateDashboard(self, data):
    # 更新UI组件
    pass
```

## 仪表盘数据集成

### 步骤1：修改数据加载函数

找到负责加载仪表盘数据的函数，并修改为从数据库获取数据：

```python
def loadDashboardData(self):
    """从数据库加载仪表盘数据"""
    try:
        # 导入必要的模块
        import sqlite3
        from datetime import datetime
        
        # 连接数据库（替换为您的数据库路径）
        conn = sqlite3.connect("path/to/your/database.db")
        cursor = conn.cursor()
        
        # 获取业务事件数量
        cursor.execute("SELECT COUNT(*) FROM business_events")
        business_count = cursor.fetchone()[0]
        
        # 获取今日新增业务事件数量
        today = datetime.now().strftime("%Y-%m-%d")
        cursor.execute("SELECT COUNT(*) FROM business_events WHERE date(created_at) = ?", (today,))
        today_business_count = cursor.fetchone()[0]
        
        # 获取财务记录数量
        cursor.execute("SELECT COUNT(*) FROM financial_transactions")
        finance_count = cursor.fetchone()[0]
        
        # 获取本月财务记录数量
        current_month = datetime.now().strftime("%Y-%m")
        cursor.execute("SELECT COUNT(*) FROM financial_transactions WHERE strftime('%Y-%m', transaction_date) = ?", (current_month,))
        month_finance_count = cursor.fetchone()[0]
        
        # 获取待审批数量
        cursor.execute("SELECT COUNT(*) FROM approvals WHERE status = '待审批'")
        pending_count = cursor.fetchone()[0]
        
        # 获取已处理审批数量
        cursor.execute("SELECT COUNT(*) FROM approvals WHERE status IN ('已通过', '已拒绝')")
        processed_count = cursor.fetchone()[0]
        
        # 获取预算执行率
        current_year = datetime.now().year
        current_month = datetime.now().month
        cursor.execute("""
            SELECT COALESCE(SUM(used_amount) / NULLIF(SUM(amount), 0) * 100, 0) 
            FROM budgets 
            WHERE year = ? AND month = ?
        """, (current_year, current_month))
        budget_rate_result = cursor.fetchone()
        budget_rate = budget_rate_result[0] if budget_rate_result and budget_rate_result[0] is not None else 0
        
        # 获取总预算金额
        cursor.execute("""
            SELECT COALESCE(SUM(amount), 0)
            FROM budgets
            WHERE year = ?
        """, (current_year,))
        total_budget_result = cursor.fetchone()
        total_budget = total_budget_result[0] if total_budget_result else 0
        
        conn.close()
        
        # 更新UI
        self.updateDashboardStats({
            "business_count": business_count,
            "today_business_count": today_business_count,
            "finance_count": finance_count,
            "month_finance_count": month_finance_count,
            "pending_count": pending_count,
            "processed_count": processed_count,
            "budget_rate": budget_rate,
            "total_budget": total_budget
        })
        
        return True
        
    except Exception as e:
        print(f"加载仪表盘数据失败: {str(e)}")
        import traceback
        traceback.print_exc()
        return False
```

### 步骤2：修改更新UI函数

确保有一个函数来更新仪表盘UI组件：

```python
def updateDashboardStats(self, data):
    """更新仪表盘统计数据"""
    # 更新业务事件数量
    self.business_count_label.setText(str(data.get("business_count", 0)))
    self.today_business_label.setText(f"今日新增: {data.get('today_business_count', 0)}")
    
    # 更新财务记录数量
    self.finance_count_label.setText(str(data.get("finance_count", 0)))
    self.month_finance_label.setText(f"本月: {data.get('month_finance_count', 0)}")
    
    # 更新待审批数量
    self.pending_count_label.setText(str(data.get("pending_count", 0)))
    self.processed_label.setText(f"已处理: {data.get('processed_count', 0)}")
    
    # 更新预算执行率
    budget_rate = data.get("budget_rate", 0)
    self.budget_rate_label.setText(f"{budget_rate:.1f}%")
    self.total_budget_label.setText(f"总预算: ¥{data.get('total_budget', 0):,.2f}")
```

## 扇形图数据集成

### 步骤1：修改扇形图数据加载函数

```python
def loadPieChartData(self):
    """从数据库加载扇形图数据"""
    try:
        import sqlite3
        
        # 连接数据库
        conn = sqlite3.connect("path/to/your/database.db")
        conn.row_factory = sqlite3.Row  # 使结果可以通过列名访问
        cursor = conn.cursor()
        
        # 获取业务类型分布
        cursor.execute("""
            SELECT 
                event_type as label, 
                COUNT(*) as value
            FROM 
                business_events
            GROUP BY 
                event_type
            ORDER BY 
                value DESC
            LIMIT 5
        """)
        
        results = cursor.fetchall()
        conn.close()
        
        # 如果没有数据，使用默认数据
        if not results:
            self.createPieChart({
                "labels": ["暂无数据"],
                "values": [1]
            })
            return False
        
        # 准备数据
        labels = []
        values = []
        
        for row in results:
            labels.append(row["label"])
            values.append(row["value"])
        
        # 更新饼图
        self.createPieChart({
            "labels": labels,
            "values": values
        })
        
        return True
        
    except Exception as e:
        print(f"加载饼图数据失败: {str(e)}")
        import traceback
        traceback.print_exc()
        
        # 使用默认数据
        self.createPieChart({
            "labels": ["销售", "采购", "报销", "合同", "其他"],
            "values": [35, 25, 20, 15, 5]
        })
        
        return False
```

### 步骤2：修改饼图创建函数

```python
def createPieChart(self, data):
    """创建饼状图"""
    # 清除之前的图表
    self.pie_figure.clear()
    
    # 创建子图
    ax = self.pie_figure.add_subplot(111)
    
    # 准备数据
    labels = data.get("labels", [])
    values = data.get("values", [])
    
    # 如果只有"暂无数据"，显示提示文本
    if labels == ["暂无数据"]:
        ax.text(0.5, 0.5, '暂无数据', ha='center', va='center', fontsize=12, color='#FFFFFF')
        ax.axis('off')  # 隐藏坐标轴
        self.pie_canvas.draw()
        return
    
    # 设置颜色
    colors = ['#1976D2', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0']
    
    # 绘制饼图
    wedges, texts, autotexts = ax.pie(
        values, 
        labels=None,  # 不直接在饼图上显示标签
        autopct='%1.1f%%', 
        startangle=90, 
        colors=colors[:len(labels)],
        wedgeprops={'edgecolor': '#121212', 'linewidth': 1},
        textprops={'color': '#FFFFFF', 'fontsize': 10}
    )
    
    # 设置标签和百分比的字体颜色
    for autotext in autotexts:
        autotext.set_color('#FFFFFF')
    
    # 添加图例，放在饼图右侧
    ax.legend(
        wedges, 
        labels, 
        title="业务类型", 
        loc="center left", 
        bbox_to_anchor=(1, 0, 0.5, 1),
        fontsize=9,
        frameon=False,  # 移除图例边框
        title_fontsize=10
    )
    
    # 设置标题
    ax.set_title('业务类型分布', fontsize=12, color='#FFFFFF')
    
    # 等比例显示
    ax.axis('equal')
    
    # 调整布局，确保图例完全显示
    self.pie_figure.tight_layout()
    
    # 刷新画布
    self.pie_canvas.draw()
```

## 折线图数据集成

### 步骤1：修改折线图数据加载函数

```python
def loadLineChartData(self):
    """从数据库加载折线图数据"""
    try:
        import sqlite3
        from datetime import datetime, timedelta
        
        # 连接数据库
        conn = sqlite3.connect("path/to/your/database.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # 获取最近7天的日期范围
        end_date = datetime.now()
        start_date = end_date - timedelta(days=6)
        
        # 生成日期列表
        dates = []
        date_labels = []
        current_date = start_date
        while current_date <= end_date:
            date_str = current_date.strftime("%Y-%m-%d")
            dates.append(date_str)
            date_labels.append(current_date.strftime("%m-%d"))
            current_date += timedelta(days=1)
        
        # 获取收入数据
        income_data = [0] * len(dates)
        cursor.execute("""
            SELECT 
                date(transaction_date) as date, 
                SUM(amount) as total
            FROM 
                financial_transactions
            WHERE 
                direction = '收入' 
                AND date(transaction_date) BETWEEN ? AND ?
            GROUP BY 
                date(transaction_date)
        """, (start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d")))
        
        for row in cursor.fetchall():
            if row["date"] in dates:
                idx = dates.index(row["date"])
                income_data[idx] = row["total"]
        
        # 获取支出数据
        expense_data = [0] * len(dates)
        cursor.execute("""
            SELECT 
                date(transaction_date) as date, 
                SUM(amount) as total
            FROM 
                financial_transactions
            WHERE 
                direction = '支出' 
                AND date(transaction_date) BETWEEN ? AND ?
            GROUP BY 
                date(transaction_date)
        """, (start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d")))
        
        for row in cursor.fetchall():
            if row["date"] in dates:
                idx = dates.index(row["date"])
                expense_data[idx] = row["total"]
        
        conn.close()
        
        # 更新折线图
        self.createLineChart({
            "dates": date_labels,
            "income": income_data,
            "expense": expense_data
        })
        
        return True
        
    except Exception as e:
        print(f"加载折线图数据失败: {str(e)}")
        import traceback
        traceback.print_exc()
        
        # 使用默认数据
        self.createLineChart({
            "dates": ["04-20", "04-21", "04-22", "04-23", "04-24", "04-25", "04-26"],
            "income": [10000, 15000, 12000, 18000, 20000, 17000, 22000],
            "expense": [8000, 12000, 10000, 15000, 13000, 16000, 14000]
        })
        
        return False
```

### 步骤2：修改折线图创建函数

```python
def createLineChart(self, data):
    """创建折线图"""
    # 清除之前的图表
    self.line_figure.clear()
    
    # 创建子图
    ax = self.line_figure.add_subplot(111)
    
    # 准备数据
    dates = data.get("dates", [])
    income = data.get("income", [])
    expense = data.get("expense", [])
    
    # 如果没有数据，显示提示
    if not dates or (not any(income) and not any(expense)):
        ax.text(0.5, 0.5, '暂无数据', ha='center', va='center', fontsize=12, color='#FFFFFF')
        ax.axis('off')  # 隐藏坐标轴
        self.line_canvas.draw()
        return
    
    # 绘制折线图
    ax.plot(dates, income, marker='o', linestyle='-', color='#4CAF50', linewidth=2, label='收入')
    ax.plot(dates, expense, marker='o', linestyle='-', color='#F44336', linewidth=2, label='支出')
    
    # 设置图表属性
    ax.set_xlabel('日期', fontsize=10, color='#E0E0E0')
    ax.set_ylabel('金额（元）', fontsize=10, color='#E0E0E0')
    ax.set_title('财务趋势', fontsize=12, color='#FFFFFF')
    
    # 设置网格线
    ax.grid(True, linestyle='--', alpha=0.3, color='#666666')
    
    # 设置背景色为透明
    ax.set_facecolor('#121212')
    
    # 设置轴线颜色
    ax.spines['bottom'].set_color('#666666')
    ax.spines['top'].set_color('#666666')
    ax.spines['left'].set_color('#666666')
    ax.spines['right'].set_color('#666666')
    
    # 设置刻度标签颜色
    ax.tick_params(axis='x', colors='#E0E0E0')
    ax.tick_params(axis='y', colors='#E0E0E0')
    
    # 添加图例
    ax.legend(frameon=False, fontsize=9, loc='upper right')
    
    # 调整布局
    self.line_figure.tight_layout()
    
    # 刷新画布
    self.line_canvas.draw()
```

## 完整代码示例

### 步骤1：修改初始化函数

确保在初始化函数中调用数据加载函数：

```python
def initUI(self):
    """初始化UI"""
    # 创建UI组件
    # ...
    
    # 设置图表样式
    self.setupChartStyles()
    
    # 加载数据
    self.loadDashboardData()
    self.loadPieChartData()
    self.loadLineChartData()
```

### 步骤2：添加刷新函数

添加一个刷新函数，用于手动或自动刷新数据：

```python
def refreshData(self):
    """刷新所有数据"""
    self.loadDashboardData()
    self.loadPieChartData()
    self.loadLineChartData()
```

### 步骤3：设置图表样式

添加一个函数来设置图表的全局样式：

```python
def setupChartStyles(self):
    """设置图表样式"""
    import matplotlib.pyplot as plt
    
    # 设置matplotlib样式
    plt.style.use('dark_background')
    
    # 设置中文字体支持
    plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei', 'SimSun', 'Arial Unicode MS']
    plt.rcParams['axes.unicode_minus'] = False  # 解决负号显示问题
    
    # 设置图表背景色
    for fig in [self.pie_figure, self.line_figure]:
        fig.patch.set_facecolor('#121212')
```

## 测试与调试

### 步骤1：测试数据库连接

在实施上述修改前，先测试数据库连接是否正常：

```python
def testDatabaseConnection(self):
    """测试数据库连接"""
    try:
        import sqlite3
        
        # 连接数据库
        conn = sqlite3.connect("path/to/your/database.db")
        cursor = conn.cursor()
        
        # 执行简单查询
        cursor.execute("SELECT sqlite_version()")
        version = cursor.fetchone()
        
        conn.close()
        
        print(f"数据库连接成功，SQLite版本: {version[0]}")
        return True
        
    except Exception as e:
        print(f"数据库连接失败: {str(e)}")
        return False
```

### 步骤2：逐步实施修改

1. 先实施数据库连接测试
2. 然后实施仪表盘数据集成
3. 接着实施扇形图数据集成
4. 最后实施折线图数据集成

每完成一步，都进行测试，确保功能正常。

### 步骤3：添加日志记录

为了便于调试，添加详细的日志记录：

```python
def setupLogging(self):
    """设置日志记录"""
    import logging
    
    # 配置日志
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        filename='dashboard.log',
        filemode='a'
    )
    
    self.logger = logging.getLogger('Dashboard')
    self.logger.info('Dashboard initialized')
```

## 常见问题解决

### 1. 数据库连接失败

**问题**：无法连接到数据库
**解决方案**：
- 确认数据库文件路径是否正确
- 检查数据库文件是否存在
- 确认SQLite库是否正确安装

### 2. SQL查询错误

**问题**：SQL查询执行失败
**解决方案**：
- 检查SQL语法是否正确
- 确认表名和字段名是否正确
- 使用try-except捕获并打印详细错误信息

### 3. 图表显示问题

**问题**：图表显示不正常或为空
**解决方案**：
- 检查数据是否正确获取
- 确认matplotlib是否正确安装
- 检查中文字体设置是否正确

### 4. 性能问题

**问题**：数据加载速度慢
**解决方案**：
- 优化SQL查询，添加适当的索引
- 实现数据缓存机制
- 考虑使用异步加载数据

### 5. 中文显示问题

**问题**：图表中的中文显示为方块或乱码
**解决方案**：
- 确保正确设置matplotlib的字体
- 尝试使用系统已安装的中文字体
- 如果问题仍然存在，考虑使用图片标签代替文字

---

通过按照本指南进行修改，您的仪表盘、扇形图和折线图将使用数据库中的实际数据，而不是模拟数据。这将使您的系统更加实用和有价值。

如果您在实施过程中遇到任何问题，请参考上述常见问题解决方案，或者查阅相关文档和资源。
