# 审批功能问题汇总与解决方案

## 概述

本文档汇总了业财融合管理系统中审批功能的常见问题及其解决方案，包括审批数据不显示问题和审批操作失败问题。这些问题影响了系统的正常使用，需要及时解决。

## 一、审批数据不显示问题

### 问题描述

在业财融合管理系统中，当用户成功提交业务事件到审批流程后（收到成功提示），切换到审批管理界面却看不到该条待审批的数据。即使点击刷新按钮，也无法看到新提交的审批数据。

### 问题原因

1. **API端点筛选条件问题**：
   - `/approvals` API端点默认只返回当前用户是审批人且状态为"待审批"的记录
   - 管理员用户可以查看所有审批记录，但可能存在隐含的筛选条件

2. **审批任务创建问题**：
   - 提交业务事件到审批流程时，可能没有找到匹配的审批配置
   - 审批任务创建逻辑可能存在问题
   - 审批任务可能创建成功，但状态不是"待审批"

3. **审批配置与用户角色不匹配**：
   - 当前登录用户可能没有在 `approval_configs` 表中配置审批权限
   - 业务事件的类型/部门与配置不匹配

### 解决方案

1. **修改API端点，添加状态筛选参数**：
   ```python
   @app.get("/approvals")
   async def get_approvals(status: str = None, current_user = Depends(get_current_user)):
       conn = get_db_connection()
       
       # 构建基本查询
       query = """
           SELECT a.*, be.project_name, be.event_type, be.amount, u.username as approver_name
           FROM approvals a
           JOIN business_events be ON a.business_event_id = be.id
           JOIN users u ON a.approver_id = u.id
       """
       params = []
       
       # 添加条件
       conditions = []
       
       # 非管理员只能查看自己的审批
       if current_user["role"] != "管理员":
           conditions.append("a.approver_id = ?")
           params.append(current_user["id"])
       
       # 如果指定了状态，添加状态筛选
       if status:
           conditions.append("a.status = ?")
           params.append(status)
       
       # 组合条件
       if conditions:
           query += " WHERE " + " AND ".join(conditions)
       
       # 添加排序
       query += " ORDER BY a.created_at DESC"
       
       # 执行查询
       approvals = conn.execute(query, params).fetchall()
       conn.close()
       
       return [dict(approval) for approval in approvals]
   ```

2. **修改前端代码，添加状态筛选功能**：
   ```python
   def load_data(self, status=None):
       """加载审批数据"""
       try:
           # 构建URL
           url = "http://localhost:8000/approvals"
           if status:
               url += f"?status={status}"
               
           response = requests.get(
               url,
               headers={"Authorization": f"Bearer {self.token}"}
           )
           
           if response.status_code == 200:
               self.data = response.json()
               self.display_data()
           else:
               QMessageBox.warning(self, "加载失败", "无法加载审批数据")
       except Exception as e:
           QMessageBox.warning(self, "错误", f"加载审批数据时发生错误: {str(e)}")
   ```

3. **检查并添加审批配置**：
   ```sql
   -- 查看业务事件的详细信息
   SELECT id, event_type, department_id, amount, status FROM business_events WHERE id = 业务事件ID;

   -- 为用户添加对应的审批配置
   INSERT INTO approval_configs (event_type, department_id, approver_id, approval_level, amount_threshold, is_active)
   VALUES ('业务事件类型', 业务事件部门ID, 用户ID, 1, 0.00, 1);
   ```

4. **修改提交审批的API端点，确保正确创建审批任务**：
   ```python
   @app.post("/business_events/{event_id}/submit-to-approval")
   async def submit_to_approval(event_id: int, current_user = Depends(get_current_user)):
       # ... 其他代码 ...
       
       # 如果没有找到匹配的审批配置，使用默认配置
       if len(configs) == 0:
           # 默认分配给管理员审批
           cursor.execute("""
               INSERT INTO approvals (business_event_id, approver_id, approval_level, status)
               SELECT ?, id, 1, '待审批'
               FROM users
               WHERE role = '管理员'
               LIMIT 1
           """, (event_id,))
       
       # ... 其他代码 ...
   ```

## 二、审批操作失败问题

### 问题描述

在审批管理界面点击"通过"或"拒绝"按钮时，系统返回错误提示："审批通过失败: Internal Server Error"或"审批通过失败: no such column: approved_at"，无法完成审批操作。

### 问题原因

1. **列名不匹配问题**：
   - 代码中使用了 `approved_at` 列，但数据库中的列名是 `approval_date`
   - SQL语句尝试更新不存在的列，导致错误

2. **状态历史表缺失问题**：
   - 代码尝试将状态变更记录插入到 `status_history` 表中，但该表可能不存在
   - 虽然使用了try-except块，但可能存在其他未捕获的异常

3. **错误处理不完善**：
   - 代码中的错误处理不够完善，未能正确捕获和处理所有可能的异常
   - 未返回明确的错误信息，导致难以定位问题

### 解决方案

1. **修改代码，使用正确的列名**：
   ```python
   # 更新审批状态
   cursor.execute(
       "UPDATE approvals SET status = '已通过', approval_date = datetime('now') WHERE id = ?",
       (approval_id,)
   )
   ```

2. **创建状态历史表**：
   ```sql
   -- 状态历史表
   CREATE TABLE IF NOT EXISTS status_history (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       business_event_id INTEGER NOT NULL,         -- 业务事件ID
       timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 状态变更时间
       status TEXT NOT NULL,                       -- 状态
       operator TEXT NOT NULL,                     -- 操作人
       remarks TEXT,                               -- 备注
       FOREIGN KEY (business_event_id) REFERENCES business_events (id)
   );
   ```

3. **增强错误处理**：
   ```python
   @app.post("/approvals/{approval_id}/approve")
   async def approve(approval_id: int, current_user = Depends(get_current_user)):
       conn = None
       try:
           conn = get_db_connection()
           cursor = conn.cursor()
           
           # ... 其他代码 ...
           
           # 更新审批状态
           cursor.execute(
               "UPDATE approvals SET status = '已通过', approval_date = datetime('now') WHERE id = ?",
               (approval_id,)
           )
           
           # ... 其他代码 ...
           
           # 记录状态变更历史（如果有状态历史表）
           try:
               cursor.execute("""
                   INSERT INTO status_history (business_event_id, timestamp, status, operator, remarks)
                   VALUES (?, datetime('now'), ?, ?, '审批通过')
               """, (approval["business_event_id"], new_status, current_user["username"]))
           except Exception as e:
               # 记录错误但不中断流程
               print(f"记录状态历史失败: {str(e)}")
           
           conn.commit()
           return {"message": "审批已通过", "next_approval": next_approval is not None}
       except HTTPException as e:
           # 重新抛出HTTP异常
           raise e
       except Exception as e:
           # 记录错误并返回友好的错误信息
           print(f"审批过程中发生错误: {str(e)}")
           raise HTTPException(status_code=500, detail=f"审批处理失败: {str(e)}")
       finally:
           # 确保连接被关闭
           if conn:
               conn.close()
   ```

4. **添加全局异常处理器**：
   ```python
   @app.exception_handler(Exception)
   async def global_exception_handler(request: Request, exc: Exception):
       # 记录异常
       print(f"全局异常: {str(exc)}")
       import traceback
       traceback.print_exc()
       
       # 返回友好的错误信息
       return JSONResponse(
           status_code=500,
           content={"detail": "服务器内部错误，请联系管理员"}
       )
   ```

## 三、实施建议

### 短期解决方案

1. **修复列名不匹配问题**：
   - 立即修改代码，将 `approved_at` 改为 `approval_date`
   - 这是最简单、风险最低的解决方案

2. **添加状态筛选功能**：
   - 在前端添加状态筛选下拉菜单
   - 修改API端点，支持状态筛选参数

### 中长期改进

1. **完善数据库架构**：
   - 创建缺失的 `status_history` 表
   - 使用数据库迁移工具管理架构变更

2. **增强错误处理**：
   - 在所有API端点中添加适当的错误处理
   - 添加全局异常处理器
   - 返回明确的错误信息

3. **改进审批配置管理**：
   - 添加审批配置管理界面
   - 确保每种业务事件类型和部门都有对应的审批配置

4. **添加日志记录**：
   - 在关键操作中添加详细的日志记录
   - 记录操作的输入参数、执行结果和可能的错误

## 四、总结

审批功能的问题主要集中在两个方面：审批数据不显示和审批操作失败。这些问题的根本原因是代码与数据库架构不一致、错误处理不完善以及审批配置不完整。

通过修改代码、完善数据库架构、增强错误处理和改进审批配置管理，可以有效解决这些问题，提高系统的稳定性和用户体验。

短期内，可以先修复列名不匹配问题和添加状态筛选功能，快速解决当前的紧急问题。中长期来看，应该完善数据库架构、增强错误处理、改进审批配置管理和添加日志记录，从根本上解决问题。
